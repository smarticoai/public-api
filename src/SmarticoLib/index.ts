// Generated by dts-bundle-generator v9.5.1

declare enum CJMActivityType {
	Root = 0,
	Journey_Started = 1,
	Journey_Stopped = 2,
	Journey_Converted = 3,
	Delay = 6,
	Control_Group = 7,
	Do_Nothing = 8,
	WaitForEvent = 9,
	DeepLink = 10,
	JSCode = 11,
	Banner = 20,
	Popup = 30,
	Inbox = 31,
	Push = 40,
	Email = 50,
	SMS = 60,
	Slack = 70,
	Email_To_Customer_Support = 80,
	Email_To_Risk_Operator = 90,
	Give_Bonus = 100,
	WebHook = 200,
	UserStateCheck = 201,
	Pixel = 300,
	WhatsApp_Connect = 400,
}
declare enum PublicLabelSettings {
	PUBLIC_API_URL = 'PUBLIC_API_URL',
	FCM_CLIENT_CONFIG = 'FCM_CLIENT_CONFIG',
	FCM_SW_URL_V2 = 'FCM_SW_URL_V2',
	RECORDING_ENABLED_FOR_ALL_USERS = 'RECORDING_ENABLED_FOR_ALL_USERS',
	JS_INJECTION = 'JS_INJECTION',
	GAMIFICATION_UI_MAIN = 'GAMIFICATION_UI_MAIN',
	GAMIFICATION_UI_WIDGET = 'GAMIFICATION_UI_WIDGET',
	GAMIFICATION_UI_MINI_GAME = 'GAMIFICATION_UI_MINI_GAME',
	GAMIFICATION_UI_SETTINGS_V2 = 'GAMIFICATION_UI_SETTINGS_V2',
	GAMIFICATION_UI_MAIN_TEST = 'GAMIFICATION_UI_MAIN_TEST',
	GAMIFICATION_UI_WIDGET_TEST = 'GAMIFICATION_UI_WIDGET_TEST',
	GAMIFICATION_UI_SETTINGS_TEST_V2 = 'GAMIFICATION_UI_SETTINGS_TEST_V2',
	FRONT_END_ALLOWED_LANGUAGES = 'FRONT_END_ALLOWED_LANGUAGES',
	FRONT_END_ALLOW_DOMAINS = 'FRONT_END_ALLOW_DOMAINS',
	DELAY_ENGAGEMENT_EXECUTION_ON_LOGIN_MS = 'DELAY_ENGAGEMENT_EXECUTION_ON_LOGIN_MS',
	SHADOW_LABEL_PUBLIC_KEY = 'SHADOW_LABEL_PUBLIC_KEY',
	DYNAMIC_IMAGE_DOMAIN = 'DYNAMIC_IMAGE_DOMAIN',
	GAMIFICATION_MATCHX_NEW_VERSION = 'GAMIFICATION_MATCHX_NEW_VERSION',
	GAMIFICATION_WIDGET_BG_OPACITY = 'GAMIFICATION_WIDGET_BG_OPACITY',
	GAMIFICATION_POPUP_BG_OPACITY = 'GAMIFICATION_POPUP_BG_OPACITY',
	GAMIFICATION_POPUP_BG_BLUR = 'GAMIFICATION_POPUP_BG_BLUR',
	GAMIFICATION_UI_LEVEL_ENABLED = 'GAMIFICATION_UI_LEVEL_ENABLED',
	GAMIFICATION_UI_LEVEL_IMAGE_MOB = 'GAMIFICATION_UI_LEVEL_IMAGE_MOB',
	GAMIFICATION_UI_LEVEL_IMAGE_DESK = 'GAMIFICATION_UI_LEVEL_IMAGE_DESK',
	GAMIFICATION_LEVELS_LOGIC2 = 'GAMIFICATION_LEVELS_LOGIC2',
	GAMIFICATION_LEVELS_LOGIC3 = 'GAMIFICATION_LEVELS_LOGIC3',
	AVATAR_CUSTOM_IMAGE_MAX_ID = 'AVATAR_CUSTOM_IMAGE_MAX_ID',
	AVATAR_CUSTOM_IMAGE_FOLDER = 'AVATAR_CUSTOM_IMAGE_FOLDER',
	GAMIFICATION_SHOW_POWERED_BY = 'GAMIFICATION_SHOW_POWERED_BY',
	INBOX_PUBLIC_CDN = 'INBOX_PUBLIC_CDN',
	GAMIFICATION_INBOX_NEW_VERSION = 'GAMIFICATION_INBOX_NEW_VERSION',
	GAMIFICATION_INBOX_NEW_VERSION_FOR_TEST_USERS = 'GAMIFICATION_INBOX_NEW_VERSION_FOR_TEST_USERS',
	GF_TOURNAMENT_LOBBY_NEW_UI_TEST_USERS = 'GF_TOURNAMENT_LOBBY_NEW_UI_TEST_USERS',
	GF_TOURNAMENT_LOBBY_NEW_UI = 'GF_TOURNAMENT_LOBBY_NEW_UI',
	GAMIFICATION_CUSTOM_JS = 'GAMIFICATION_CUSTOM_JS',
	GAMIFICATION_DISABLE_FOR_BRAND = 'GAMIFICATION_DISABLE_FOR_BRAND',
}
declare enum PushClientPlatform {
	CHROME_DESKTOP = 0,
	FIREFOX_DESKTOP = 1,
	EDGE_DESKTOP = 2,
	OPERA_DESKTOP = 3,
	SAFARI_DESKTOP = 4,
	OTHER = 5,
	NATIVE_IOS = 6,
	NATIVE_ANDROID = 7,
	CHROME_MOBILE = 8,
	FIREFOX_MOBILE = 9,
	SAFARI_MOBILE = 10,
	OPERA_MOBILE = 11,
}
declare enum ClientActivityRequestId {
	MINI_WIDGET_SHOWN = 1,
	MINI_WIDGET_HIDDEN = 2,
	MINI_WIDGET_CLICKED = 3,
	INBOX_MESSAGE_SHOWN = 4,
	INBOX_MESSAGE_HIDDEN = 5,
	INBOX_CLICKED = 6,
	BIG_WIDGET_SHOWN = 7,
	BIG_WIDGET_HIDDEN = 8,
	MISSIONS_SHOWN = 9,
	BOARD_SHOWN = 10,
	LEVELS_SHOWN = 11,
	BONUSES_SHOWN = 12,
	STORE_SHOWN = 13,
	ACTIVITY_LOG_SHOWN = 14,
	LOGOUT = 20,
	LOGIN = 21,
	ENGAGEMENT_FAILED = 30,
	ENGAGEMENT_ACTION = 31,
	ENGAGEMENT_IMPRESSION = 32,
	MISSIONS_CLICK = 201,
}
export interface PublicProperties {
	core_user_language?: string;
	ach_points_balance?: number;
	ach_points_ever?: number;
	core_public_tags?: string[];
	ach_level_current_id?: number;
	ach_level_current?: string;
	core_is_test_account?: boolean;
	avatar_id?: string;
	ach_gamification_in_control_group?: boolean;
	ach_gamification_ui_explicitly_on?: boolean;
	public_username?: string;
	core_inbox_unread_count?: number;
	is_visitor?: boolean;
	core_registration_date?: number;
}
declare enum ClassId {
	PING = 1,
	PONG = 2,
	INIT = 3,
	INIT_RESPONSE = 4,
	IDENTIFY = 5,
	IDENTIFY_RESPONSE = 6,
	LOGIN = 7,
	LOGOUT = 8,
	EVENT = 9,
	EVENT_RESPONSE = 10,
	LOGIN_RESPONSE = 11,
	LOGOUT_RESPONSE = 12,
	GET_TRANSLATIONS_REQUEST = 13,
	GET_TRANSLATIONS_RESPONSE = 14,
	CLIENT_ENGAGEMENT_IMPRESSION_REQUEST = 103,
	CLIENT_ENGAGEMENT_ACTION_REQUEST = 104,
	CLIENT_EXECUTE_DEEPLINK_EVENT = 105,
	CLIENT_ENGAGEMENT_FAILED_REQUEST = 106,
	CLIENT_EXECUTE_JS_EVENT = 107,
	CLIENT_PUBLIC_PROPERTIES_CHANGED_EVENT = 108,
	CLIENT_ENGAGEMENT_EVENT_NEW = 110,
	CLIENT_TRACK_ACTIVITY_REQUEST = 155,
	CLIENT_SET_AVATAR_REQUEST = 157,
	CLIENT_SET_AVATAR_RESPONSE = 158,
	CLIENT_SET_CUSTOM_USERNAME_REQUEST = 159,
	CLIENT_SET_CUSTOM_USERNAME_RESPONSE = 160,
	CHECK_SEGMENT_MATCH_REQUEST = 161,
	CHECK_SEGMENT_MATCH_RESPONSE = 162,
	GET_LEVEL_MAP_REQUEST = 500,
	GET_LEVEL_MAP_RESPONSE = 501,
	GET_ACHIEVEMENT_MAP_REQUEST = 502,
	GET_ACHIEVEMENT_MAP_RESPONSE = 503,
	RELOAD_ACHIEVEMENTS_EVENT = 504,
	GET_LEADERS_BOARD_REQUEST = 505,
	GET_LEADERS_BOARD_RESPONSE = 506,
	GET_SHOP_ITEMS_REQUEST = 509,
	GET_SHOP_ITEMS_RESPONSE = 510,
	BUY_SHOP_ITEM_REQUEST = 511,
	BUY_SHOP_ITEM_RESPONSE = 512,
	GET_INBOX_MESSAGES_REQUEST = 513,
	GET_INBOX_MESSAGES_RESPONSE = 514,
	GET_SHOP_CATEGORIES_REQUEST = 515,
	GET_SHOP_CATEGORIES_RESPONSE = 516,
	GET_TOURNAMENT_LOBBY_REQUEST = 517,
	GET_TOURNAMENT_LOBBY_RESPONSE = 518,
	GET_TOURNAMENT_INFO_REQUEST = 519,
	GET_TOURNAMENT_INFO_RESPONSE = 520,
	TOURNAMENT_REGISTER_REQUEST = 521,
	TOURNAMENT_REGISTER_RESPONSE = 522,
	GET_CUSTOM_SECTIONS_REQUEST = 523,
	GET_CUSTOM_SECTIONS_RESPONSE = 524,
	MISSION_OPTIN_REQUEST = 525,
	MISSION_OPTIN_RESPONSE = 526,
	GET_ACHIEVEMENT_USER_REQUEST = 527,
	GET_ACHIEVEMENT_USER_RESPONSE = 528,
	MARK_INBOX_READ_REQUEST = 529,
	MARK_INBOX_READ_RESPONSE = 530,
	MARK_INBOX_STARRED_REQUEST = 531,
	MARK_INBOX_STARRED_RESPONSE = 532,
	MARK_INBOX_DELETED_REQUEST = 535,
	MARK_INBOX_DELETED_RESPONSE = 536,
	GET_ACH_CATEGORIES_REQUEST = 537,
	GET_ACH_CATEGORIES_RESPONSE = 538,
	ACHIEVEMENT_CLAIM_PRIZE_REQUEST = 539,
	ACHIEVEMENT_CLAIM_PRIZE_RESPONSE = 540,
	ACH_SHOP_ITEM_HISTORY_REQUEST = 541,
	ACH_SHOP_ITEM_HISTORY_RESPONSE = 542,
	GET_BONUSES_REQUEST = 600,
	GET_BONUSES_RESPONSE = 601,
	CLAIM_BONUS_REQUEST = 602,
	CLAIM_BONUS_RESPONSE = 603,
	SAW_GET_SPINS_REQUEST = 700,
	SAW_GET_SPINS_RESPONSE = 701,
	SAW_DO_SPIN_REQUEST = 702,
	SAW_DO_SPIN_RESPONSE = 703,
	SAW_AKNOWLEDGE_REQUEST = 704,
	SAW_AKNOWLEDGE_RESPONSE = 705,
	SAW_SPINS_COUNT_PUSH = 706,
	SAW_SHOW_SPIN_PUSH = 707,
	SAW_PRIZE_DROP_WIN_PUSH = 708,
	SAW_PRIZE_DROP_WIN_AKNOWLEDGE_REQUEST = 709,
	SAW_PRIZE_DROP_WIN_AKNOWLEDGE_RESPONSE = 710,
	JP_GET_JACKPOTS_REQUEST = 800,
	JP_GET_JACKPOTS_RESPONSE = 801,
	JP_GET_LATEST_POTS_REQUEST = 802,
	JP_GET_LATEST_POTS_RESPONSE = 803,
	JP_OPTIN_REQUEST = 804,
	JP_OPTIN_RESPONSE = 805,
	JP_OPTOUT_REQUEST = 806,
	JP_OPTOUT_RESPONSE = 807,
	JP_WIN_PUSH = 808,
	REGISTER_PUSH_NOTIFICATIONS_TOKEN_REQ = 1003,
	REGISTER_PUSH_NOTIFICATIONS_TOKEN_RESP = 2003,
	CLIENT_DEBUG_REQUEST = 77777,
	UNSUPPORTED_COMMAND = 99999,
}
export interface ILogger {
	debug(...any: any[]): void;
	error(...any: any[]): void;
	info(...any: any[]): void;
	warn(...any: any[]): void;
	always(...any: any[]): void;
}
declare enum BuyStoreItemErrorCode {
	FAILED_TO_BUY_SHOP_ITEM = 121,
	SHOP_NO_BALANCE = 11000,
	SHOP_WRONG_LABEL = 11001,
	SHOP_FAILED_TO_BUY_BONUS = 11002,
	SHOP_FAILED_TO_BUY_SHOP_ITEM_CONDITION = 11003,
	SHOP_FAILED_TO_BUY_SHOP_ITEM_CONDITION_PURSHASE = 11004,
	SHOP_FAILED_TO_BUY_MATCHING_BONUS = 11005,
	SHOP_FAILED_MAX_BOUGHT_ITEMS_REACHED = 11006,
	SHOP_FAILED_POOL_EMPTY = 11009,
}
export interface ProtocolMessage {
	cid: number;
	ts?: number;
	uuid?: string;
}
export interface ProtocolResponse extends ProtocolMessage {
	errCode?: number;
	errMsg?: string;
}
export interface BuyStoreItemResponse extends ProtocolResponse {
	success?: boolean;
}
export interface StoreCategoryPublicMeta {
	name?: string;
	order?: number;
}
export interface StoreCategory {
	id?: number;
	publicMeta?: StoreCategoryPublicMeta;
}
export interface GetCategoriesStoreResponse extends ProtocolResponse {
	categories: StoreCategory[];
}
export interface StoreItemPublicMeta {
	price: string;
	image_url: string;
	name: string;
	description: string;
	label_tag: string;
	custom_label_tag?: string;
	limit_message: string;
	priority: number;
	related_items: number[];
	hint_text: string;
	show_timer?: boolean;
	cant_buy_message?: string;
	discount_prize?: number;
	discount_prize_ribbon?: string;
	custom_ribbon_image?: string;
}
declare enum StoreItemType {
	Bonus = 1,
	Manual = 2,
}
export interface StoreItem {
	id: number;
	itemTypeId: StoreItemType;
	itemPublicMeta: StoreItemPublicMeta;
	categoryIds?: number[];
	canBuy?: boolean;
	shopPool: number;
	activeTillDate?: number;
}
export interface GetStoreItemsResponse extends ProtocolResponse {
	items: StoreItem[];
}
export interface StoreItemPurchased extends StoreItem {
	purchase_ts: number;
	purchase_points_amount: number;
}
export interface GetStoreHistoryResponse extends ProtocolResponse {
	items: StoreItemPurchased[];
	hasMore: boolean;
}
declare enum SAWBuyInType {
	Free = 1,
	Points = 2,
	Spins = 3,
	Gems = 4,
	Diamonds = 5,
}
declare enum SAWBuyInTypeName {
	Free = 'free',
	Points = 'points',
	Spins = 'spins',
	Gems = 'gems',
	Diamonds = 'diamonds',
	Unknown = 'unknown',
}
declare enum SAWGameType {
	SpinAWheel = 1,
	ScratchCard = 2,
	MatchX = 3,
	GiftBox = 4,
	PrizeDrop = 5,
}
declare enum SAWGameTypeName {
	SpinAWheel = 'wheel',
	ScratchCard = 'scratch',
	MatchX = 'matchx',
	GiftBox = 'giftbox',
	PrizeDrop = 'prizedrop',
	Unknown = 'unknown',
}
declare enum SAWPrizeType {
	NO_PRIZE = 1,
	POINTS = 2,
	BONUS = 3,
	MANUAL = 4,
	SPIN = 5,
	JACKPOT = 6,
}
declare enum MiniGamePrizeTypeName {
	NO_PRIZE = 'no-prize',
	POINTS = 'points',
	BONUS = 'bonus',
	MANUAL = 'manual',
	SPIN = 'spin',
	JACKPOT = 'jackpot',
	UNKNOWN = 'unknown',
}
declare enum SAWAcknowledgeType {
	Silent = 1,
	QuickMessage = 2,
	FullMessage = 3,
}
declare enum SAWWinSoundType {
	Disappointing = 1,
	Positive = 2,
	HighlyPositive = 3,
	NoSound = 4,
	Custom = 5,
}
export interface SAWPrizeUI {
	position?: number;
	name: string;
	name_original: string;
	hide_prize_popup: boolean;
	aknowledge_message: string;
	sectors: number[];
	acknowledge_type: SAWAcknowledgeType;
	acknowledge_dp?: string;
	font_size?: number;
	font_size_mobile?: number;
	sound_type: SAWWinSoundType;
	icon?: string;
	replace_name_with_image?: boolean;
	acknowledge_action_title?: string;
	custom_win_sound?: string;
}
export interface SAWPrize {
	saw_prize_id: number;
	saw_prize_ui_definition: SAWPrizeUI;
	prize_value?: number;
	prize_type_id: SAWPrizeType;
	place_from?: number;
	place_to?: number;
	sawUniqueWinId?: string;
}
declare enum SAWAskForUsername {
	NOASK = 'no-ask',
	ONSUMBIT = 'on-submit',
}
export interface SAWTemplateUI {
	skin: string;
	name: string;
	description?: string;
	over_limit_message?: string;
	hide_prize_names?: string;
	no_attempts_message?: string;
	thumbnail?: string;
	sectors_count: number;
	priority: number;
	flow_builder_only: boolean;
	background_image?: string;
	background_image_mobile?: string;
	background_sound?: string;
	spin_animation_duration?: number;
	scratch_logo?: string;
	scratch_cover?: string;
	scratch_bg_desktop?: string;
	scratch_bg_mobile?: string;
	scratch_cursor?: string;
	custom_css?: string;
	custom_skin_folder?: string;
	jackpot_symbol?: string;
	promo_image?: string;
	promo_text?: string;
	matchx_banner?: string;
	matchx_seasonal_ranking?: boolean;
	matchx_is_completed?: boolean;
	matchx_general_board_users_count?: number;
	matchx_hide_ranking?: boolean;
	prize_pool_image?: string;
	ask_for_username?: SAWAskForUsername;
	show_prize_board?: boolean;
	max_spins_period_ms?: number;
	show_countdown_for_next_availability?: boolean;
	disable_background_music?: boolean;
	custom_section_id?: number;
	only_in_custom_section?: boolean;
	custom_data: any;
	placeholder1?: string;
	placeholder2?: string;
	prize_drop_template?: {
		id: string;
		content: string;
	};
}
export interface SAWTemplate {
	saw_template_id: number;
	saw_game_type_id: SAWGameType;
	saw_template_ui_definition: SAWTemplateUI;
	saw_buyin_type_id: SAWBuyInType;
	buyin_cost_points?: number;
	visibile_when_can_spin: boolean;
	spin_count?: number;
	prizes: SAWPrize[];
	is_visible: boolean;
	jackpot_add_on_attempt: number;
	jackpot_current: number;
	jackpot_guaranteed: number;
	maxActiveSpinsAllowed: number;
	maxSpinsCount: number;
	maxSpinsPediodMs: number;
	next_available_spin_ts?: number;
	saw_skin_key: string;
	saw_skin_ui_definition: {
		skin_folder: string;
		skin_css: string;
	};
}
declare enum SAWSpinErrorCode {
	/** No error */
	SAW_OK = 0,
	/** User doesn't have 'spin attempts' to play. In case buy in type for the game is 'spins' based */
	SAW_NO_SPINS = 40001,
	/** The are no prizes left to play the game */
	SAW_PRIZE_POOL_EMPTY = 40002,
	/** User doesn't have enough points to play. In case buy in type for the game is 'points' based */
	SAW_NOT_ENOUGH_POINTS = 40003,
	/** User reached max number of game attempts defined in the BackOffice */
	SAW_FAILED_MAX_SPINS_REACHED = 40004,
	/** Special code for the 'visitor' mode */
	SAW_VISITOR_STOP_SPIN_REQUEST = -40001,
}
export interface SAWDoSpinResponse extends ProtocolResponse {
	errCode: SAWSpinErrorCode;
	errMsg?: string;
	request_id: string;
	saw_prize_id: number;
	jackpot_amount?: number;
	first_spin_in_period: number;
	visitor_win_uuid?: string;
}
export interface SAWDoAknowledgeResponse extends ProtocolMessage {
	request_id: string;
}
declare enum TournamentRegistrationType {
	AUTO = 1,
	OPT_IN = 2,
	BUY_IN_POINTS = 3,
	MANUAL_APPROVAL = 4,
	REQUIRES_QUALIFICATION = 5,
	BUY_IN_GEMS = 6,
	BUY_IN_DIAMONDS = 7,
}
/*
AUTO – The user is automatically registered upon their first qualifying action; no manual action is required.
OPT_IN – Free registration; the user simply needs to click "Join."
BUY_IN_POINTS – Registration requires points; the required amount is specified in the registration_cost_points field.
MANUAL_APPROVAL – The user must join, but the operator must approve the registration from the back office.
REQUIRES_QUALIFICATION – The user must join and complete the required qualification action specified for the tournament.
*/
export type TournamentRegistrationTypeName =
	| 'AUTO'
	| 'OPT_IN'
	| 'BUY_IN_POINTS'
	| 'MANUAL_APPROVAL'
	| 'REQUIRES_QUALIFICATION'
	| 'BUY_IN_GEMS'
	| 'BUY_IN_DIAMONDS'
	| 'UNKNOWN';
declare enum TournamentInstanceStatus {
	PUBLISHED = 1,
	REGISTER = 2,
	STARTED = 3,
	FINISHED = 4,
	CANCELLED = 5,
	FAILED = 6,
	FINALIZING = 7,
}
declare enum TournamentRegistrationStatus {
	NOT_REGISTERED = 0,
	REGISTERED = 1,
	FINISHED = 2,
	PENDING = 3,
	CANCELLED = 4,
	REGISTERED_PENDING_QUALIFICATION = 5,
	QUALIFIED_PENDING_REGISTRATION = 6,
}
declare enum TournamentRegistrationStatusName {
	NOT_REGISTERED = 'NOT_REGISTERED',
	REGISTERED = 'REGISTERED',
	FINISHED = 'FINISHED',
	PENDING = 'PENDING',
	CANCELLED = 'CANCELLED',
	REGISTERED_PENDING_QUALIFICATION = 'REGISTERED_PENDING_QUALIFICATION',
	QUALIFIED_PENDING_REGISTRATION = 'QUALIFIED_PENDING_REGISTRATION',
	UNKNOWN = 'UNKNOWN',
}
declare enum TournamentType {
	SCHEDULED = 1,
	SNG = 2,
	TEST = 3,
}
export interface TournamentPublicMeta {
	/** Name of tournament */
	name?: string;
	/** 1st image */
	image_url?: string;
	/** 2nd image */
	image_url2?: string;
	/** 2nd image for mobile */
	image_url2_mobile?: string;
	/** Description, html capable */
	description?: string;
	/** Short explanation of prize pool */
	prize_pool_short?: string;
	/** Message to show when user is not matching to the segment allowed to register (error code 30005 in registration response) */
	segment_dont_match_message?: string;
	/** Short explanation of registration price */
	custom_price_text?: string;
	/** Indicator if the scores of other users should be shown in the leaderboard of tournament */
	show_other_users_score?: boolean;
	custom_section_id?: number;
	only_in_custom_section?: boolean;
	label_tag?: string;
	custom_label_tag?: string;
	featured?: boolean;
	position?: number;
	custom_data?: string;
}
export interface AchRelatedGame {
	ach_game_id: number;
	ext_game_id: string;
	game_public_meta: {
		name: string;
		link: string;
		image: string;
		enabled: boolean;
		game_categories?: string[];
		game_provider?: string;
	};
}
export interface Tournament {
	/** ID of tournament template */
	tournamentId?: number;
	/** ID of tournament instance. Generated every time when tournament based on specific template is scheduled for run */
	tournamentInstanceId?: number;
	/** Type of the tournament. For now only SCHEDULED is support */
	tournamentType?: TournamentType;
	/** Meta information about tournament that should be used to build UI */
	publicMeta?: TournamentPublicMeta;
	/** Cost of registration in the tournament in gamification points */
	buyInAmount?: number;
	/** Not in use */
	prizePool?: number;
	/** The time when tournament is going to start */
	startTime?: string;
	/** The time when tournament is going to finish */
	endTime?: string;
	/** The time when tournament is going to start, epoch */
	startTimeTs?: number;
	/** The time when tournament is going to finish, epoch */
	endTimeTs?: number;
	/** Number of users registered in the tournament */
	registrationCount?: number;
	/** Not in use */
	totalCount?: number;
	/** Type of registration in the tournament */
	registrationType?: TournamentRegistrationType;
	/** Status of registration in the tournament for current user */
	tournamentRegistrationStatus?: TournamentRegistrationStatus;
	/** Status of tournament instance */
	tournamentInstanceStatus?: TournamentInstanceStatus;
	/** flag indicating if current user is registered in the tournament */
	isUserRegistered?: boolean;
	/** Indicator if tournament allows later registration, when tournament is already started */
	allowLateRegistration?: boolean;
	/** Minimum number of participant for this tournament. If tournament doesnt have enough registrations, it will not start */
	playersMinCount?: number;
	/** Maximum number of participant for this tournament. When reached, new users won't be able to register */
	playersMaxCount?: number;
	/** Tournament duration in millisecnnds */
	durationMs?: number;
	/** prizes structure */
	prizeStructure?: {
		prizes: TournamentPrize[];
	};
	/** Information about current user */
	tournamentPlayer?: TournamentPlayer;
	/** List of casino games (or other types of entities) related to the tournament */
	related_games?: AchRelatedGame[];
}
export interface TournamentPlayer {
	userAltName: string;
	position: number;
	scores: number;
	isMe: boolean;
	userId: number;
	avatar_id: string;
	avatar_url?: string;
}
declare enum ActivityTypeLimited {
	DoNothing = 8,
	Points = 12,
	GiveMission = 14,
	StartAnotherCampaign = 15,
	MiniGameAttempt = 16,
	DeductPoints = 21,
	ResetPoints = 22,
	Popup = 30,
	Inbox = 31,
	Slack = 70,
	Email_To_Customer_Support = 80,
	Email_To_Risk_Operator = 90,
	Bonus = 100,
	WebHook = 200,
	TagCustomer = 504,
	UnTagCustomer = 505,
}
export interface TournamentPrize {
	name: string;
	description: string;
	image_url: string;
	place_from: number;
	place_to: number;
	type: ActivityTypeLimited;
	points: number;
}
export interface GetTournamentInfoResponse extends ProtocolResponse {
	/** tournament info */
	tournamentInfo: {
		/** id of label, not in use */
		labelId: number;
		tournamentLobbyInfo: Tournament;
		/** list of registered users */
		players: TournamentPlayer[];
	};
	/** information about current user position */
	userPosition: TournamentPlayer;
	/** prizes structure */
	prizeStructure?: {
		prizes: TournamentPrize[];
	};
}
export interface GetTournamentsResponse extends ProtocolResponse {
	/** array of the tournaments */
	tournaments?: Tournament[];
}
declare enum TournamentRegistrationError {
	NO_ERROR = 0,
	TOURNAMENT_INSTANCE_NOT_FOUND = 30001,
	TOURNAMENT_REGISTRATION_NOT_ENOUGH_POINTS = 30002,
	TOURNAMENT_INSTANCE_NOT_IN_STATE = 30003,
	TOURNAMENT_ALREADY_REGISTERED = 30004,
	TOURNAMENT_USER_DONT_MATCH_CONDITIONS = 30005,
	TOURNAMENT_USER_NOT_REGISTERED = 30006,
	TOURNAMENT_CANT_CHANGE_REGISTRATION_STATUS = 30007,
	TOURNAMENT_MAX_REGISTRATIONS_REACHED = 30008,
}
export interface TournamentRegisterResponse extends ProtocolResponse {
	errCode?: TournamentRegistrationError;
}
declare enum LeaderBoardPeriodType {
	DAILY = 1,
	WEEKLY = 2,
	MONTHLY = 3,
}
export interface LeaderBoardPosition {
	public_username?: string;
	user_alt_name: string;
	position_in_board: number;
	points_accumulated: number;
	is_me: boolean;
	level_id: number;
	avatar_id: string;
	avatar_url?: string;
}
export interface LeaderBoardPublicMeta {
	name: string;
	description: string;
	rules: string;
}
export interface LeaderBoardDetails {
	board_id: number;
	period_type_id: LeaderBoardPeriodType;
	create_date?: number;
	versiod_id: number;
	reward_points: number[];
	board_public_meta: LeaderBoardPublicMeta;
	positions: LeaderBoardPosition[];
	userPosition: LeaderBoardPosition;
}
export type TRibbon = 'sale' | 'hot' | 'new' | 'vip' | string;
/**
 * TMiniGamePrize describes the information of prize in the array of prizes in the TMiniGameTemplate
 */
export interface TMiniGamePrize {
	/** ID of the prize */
	id: number;
	/** The visual name of the prize */
	name: string;
	/** The type of the prize,  no-prize, points, bonus, manual, spin, jackpot */
	prize_type: MiniGamePrizeTypeName;
	/** Numeric value of the prize in case it's pints or spin type */
	prize_value?: number;
	/** Custom font size for the prize (desktop) */
	font_size?: number;
	/** Custom font size for the prize (mobile) */
	font_size_mobile?: number;
	/** The URL of the icon of the prize */
	icon?: string;
	position: number;
	aknowledge_message: string;
	acknowledge_dp: string;
	acknowledge_action_title: string;
}
/**
 * TMiniGamePlayResult describes the response of call to _smartico.api.playMiniGame(template_id) method
 */
export interface TMiniGamePlayResult {
	/** Error code that represents outcome of the game play attempt. Game succeed to be played in case err_code is 0 */
	err_code: SAWSpinErrorCode;
	/** Optional error message */
	err_message: string;
	/** The prize_id that user won, details of the prize can be found in the mini-game definition */
	prize_id: number;
}
/**
 * TMiniGameTemplate describes the information of mini-games available for the user
 */
export interface TMiniGameTemplate {
	/** ID of the mini-game template */
	id: number;
	/** Name of the mini-game template, translated to the user language */
	name: string;
	/** Description of the mini-game template, translated to the user language */
	description: string;
	/** URL of the icon of the mini-game template */
	thumbnail: string;
	/** The type of the game, e.g. Spin the Wheel, Gift Box, Scratch card, MatchX etc */
	saw_game_type: SAWGameTypeName;
	/** How the user is charged for each game attempt e.g. Free, Points or Spin attempts */
	saw_buyin_type: SAWBuyInTypeName;
	/** in case of charging type 'Points', what is the points amount will be deducted from user balance */
	buyin_cost_points: number;
	/** in case of charging type 'Gems', what is the gems amount will be deducted from user balance */
	buyin_cost_gems: number;
	/** in case of charging type 'Diamonds', what is the diamonds amount will be deducted from user balance */
	buyin_cost_diamonds: number;
	/** in case of charging type 'Spin attempts', shows the current number of spin attempts that user has */
	spin_count?: number;
	/** if the game is limit to the number of spins that user can do during period of time, this property shows the epoch time in UTC when the next attempt will be available */
	next_available_spin_ts: number;
	/** The message that should be shown to the user when he cannot play the game, server rejected attempt with error code SAWSpinErrorCode.SAW_FAILED_MAX_SPINS_REACHED */
	over_limit_message: string;
	/** The message that should be shown to the user when he cannot play the game because he doesn't have spin attempts or points. */
	no_attempts_message: string;
	/** Current jackpont amount, if jackpot is enabled. */
	jackpot_current: number;
	/** The amount that will be added to the jackpot every time when somebody plays the game. Note that the contribution amount is abstract, means that no money or points are deducted from the user balance. */
	jackpot_add_on_attempt: number;
	/** The symbol of jackpot that is giving the sense to the 'amount' E.g. the symbol could be EUR and connected to the amount it can indicate that amount is monetary, e.g. '100 EUR'. Or the symbol can be 'Free spins' and connected to the amount it can indicate that amount is number of free spins, e.g. '100 Free spins'.
	 */
	jackpot_symbol: string;
	/** The promo image  */
	promo_image: string;
	/** The promo text  */
	promo_text: string;
	/** The custom data of the mini-game defined by operator in the BackOffice. Can be a JSON object, string or number */
	custom_data: any;
	prizes: TMiniGamePrize[];
}
/**
 * TUser describes the information of the user
 * The user object is returned by _smartico.api.getUserProfile() method.
 * If you want to track the changes of the user profile, you can subscribe to the callback in the following way
 *  _smartico.on('props_change', () => console.log(_smartico.api.getUserProfile()) );
 */
export interface TUserProfile {
	/** The language of the user */
	core_user_language: string;
	/** The current points balance that user can use in the Store, Mini-games, Tournaments, etc.. */
	ach_points_balance: number;
	/** The amount of points that user collected in total */
	ach_points_ever: number;
	/**
	 * The array of the public tags set on the user object.
	 * They can be treated as server-based cookies.
	 * You can set tags using following method _smartico.event('core_public_tags_update', { core_public_tags: ['A', 'B'] } );
	 * And then you can check for the tags
	 */
	core_public_tags: string[];
	/** The ID of the current level of the user */
	ach_level_current_id?: number;
	/** The indicator if user is marked as test user */
	core_is_test_account?: boolean;
	/** The URL to the user avatar */
	avatar_url?: string;
	/** The username of current user */
	public_username?: string;
	/** THe number of unread inbox messages */
	core_inbox_unread_count?: number;
}
/**
 * TLevel describes the information of each level defined in the system
 * There is no order of the levels, but it can be calculated using required_points property
 * The current level of user can be taken from the user object using ach_level_current_id property
 * The progress to the next level can be calculated using ach_points_ever and required_points properties of next level
 */
export interface TLevel {
	/** The ID of the Level */
	id: number;
	/** The name of the Level, translated to the user language */
	name: string;
	/** The description of the Level, translated to the user language */
	description: string;
	/** The URL of the image of the Level */
	image: string;
	/** The amount of points required to reach the Level */
	required_points: number;
	/** Number of points that user should collect in order to see this level */
	visibility_points: number;
	/**
	 * The counter of 1st metric used to reach the Level.
	 * Relevant in case of using advanced leveling logic
	 * https://help.smartico.ai/welcome/more/release-notes/september-2022#new-logic-for-leveling-users
	 *
	 */
	required_level_counter_1: number;
	/**
	 * The counter of 2nd metric used to reach the Level.
	 * Relevant in case of using advanced leveling logic
	 * https://help.smartico.ai/welcome/more/release-notes/september-2022#new-logic-for-leveling-users
	 *
	 */
	required_level_counter_2: number;
	/** 
	 * Custom data as string or JSON string that can be used in API to build custom UI
	 * You can request from Smartico to define fields for your specific case that will be managed from Smartico BackOffice
	 * Read more here - https://help.smartico.ai/welcome/products/general-concepts/custom-fields-attributes
	 */
	custom_data: string;
}
/**
 * TTournament describes the general information of the tournament item
 */
export interface TTournament {
	/** ID of tournament instance. Generated every time when tournament based on specific template is scheduled for run */
	instance_id: number;
	/** ID of tournament template */
	tournament_id: number;
	/** Name of the tournament, translated to the user language */
	name: string;
	/** Description of the tournament, translated to the user language */
	description: string;
	image1: string;
	image2: string;
	prize_pool_short: string;
	custom_price_text: string;
	/** The message that should be shown to the user when the user cannot register in tournament with error code TOURNAMENT_USER_DONT_MATCH_CONDITIONS  */
	segment_dont_match_message: string;
	/**
	 * The ID of the custom section where the tournament is assigned
	 * The list of custom sections can be retrieved using _smartico.api.getCustomSections() method (TODO-API)
	 */
	custom_section_id: number;
	/** The custom data of the tournament defined by operator. Can be a JSON object, string or number */
	custom_data: any;
	/** The indicator if the tournament is 'Featured' */
	is_featured: boolean;
	/** The ribbon of the tournament item. Can be 'sale', 'hot', 'new', 'vip' or URL to the image in case of custom ribbon */
	ribbon: TRibbon;
	/** A number is used to order the tournaments, representing their priority in the list  */
	priority: number;
	/** Info about current player in tournament */
	me?: {
		/** The username of the participant */
		public_username: string;
		/** The URL to the avatar of the participant */
		avatar_url: string;
		/** The position of the participant in the tournament */
		position: number;
		/** The scores of the participant in the tournament */
		scores: number;
	};
	/** Prize structure */
	prizes?: {
		/** The name of the prize */
		name: string;
		/** The description of the prize */
		description: string;
		/** The image of the prize */
		image_url: string;
		/** from-to range of the places to which this prize */
		place_from: number;
		place_to: number;
		/** type of the prize: TANGIBLE, POINTS_ADD, POINTS_DEDUCT, POINTS_RESET, MINI_GAME_ATTEMPT, BONUS */
		type: string;
		/** if the prize is points related, indicates amount of points */
		points?: number;
	}[];
	/** The time when tournament is going to start, epoch with milliseconds */
	start_time: number;
	/** The time when tournament is going to finish, epoch with milliseconds */
	end_time: number;
	/** Type of registration in the tournament */
	registration_type: TournamentRegistrationTypeName;
	/** Number of users registered in the tournament */
	registration_count: number;
	/** flag indicating if current user is registered in the tournament */
	is_user_registered: boolean;
	/** Minimum number of participant for this tournament. If tournament doesnt have enough registrations, it will not start */
	players_min_count: number;
	/** Maximum number of participant for this tournament. When reached, new users won't be able to register */
	players_max_count: number;
	/** Status of registration in the tournament for current user */
	registration_status: TournamentRegistrationStatusName;
	/** Tournament duration in millisecnnds */
	duration_ms: number;
	/** Cost of registration in the tournament in gamification points */
	registration_cost_points?: number;
	/** Cost of registration in the tournament in gems */
	registration_cost_gems?: number;
	/** Cost of registration in the tournament in diamonds */
	registration_cost_diamonds?: number;
	/** Indicator if tournament instance is active, means in one of the statues -  PUBLISHED, REGISTED, STARTED */
	is_active: boolean;
	/** Indicator if user can register in this tournament instance, e.g tournament is active, max users is not reached, user is not registered yet */
	is_can_register: boolean;
	/** Indicator if tournament instance is cancelled (status CANCELLED) */
	is_cancelled: boolean;
	/** Indicator if tournament instance is finished (status FINISHED, CANCELLED OR FINIALIZING) */
	is_finished: boolean;
	/** Indicator if tournament instance is running (status STARTED) */
	is_in_progress: boolean;
	/** Indicator if tournament instance is upcoming (status PUBLISHED or REGISTER) */
	is_upcoming: boolean;
}
/**
 * TTournamentDetailed describes the information of the tournament item and includes list of participants, their scores and position in the tournament leaderboard
 */
export interface TTournamentDetailed extends TTournament {
	/** List of casino games (or other types of entities) related to the tournament */
	related_games?: AchRelatedGame$1[];
	/** The list of the tournament participants */
	players?: {
		/** The username of the participant */
		public_username: string;
		/** The URL to the avatar of the participant */
		avatar_url: string;
		/** The position of the participant in the tournament */
		position: number;
		/** The scores of the participant in the tournament */
		scores: number;
		/** The indicator if the participant is current user */
		is_me: boolean;
	}[];
	/** The information about current user in the tournament if he is registered in the tournamnet */
	me?: {
		/** The username of the current user */
		public_username: string;
		/** The URL to the avatar of the current user */
		avatar_url: string;
		/** The position of the current user in the tournament */
		position: number;
		/** The scores of the current user in the tournament */
		scores: number;
	};
	prizes?: {
		/** The name of the prize */
		name: string;
		/** The description of the prize */
		description: string;
		/** The image of the prize */
		image_url: string;
		/** from-to range of the places to which this prize */
		place_from: number;
		place_to: number;
		/** type of the prize: TANGIBLE, POINTS_ADD, POINTS_DEDUCT, POINTS_RESET, MINI_GAME_ATTEMPT, BONUS */
		type: string;
		/** if the prize is points related, indicates amount of points */
		points?: number;
	}[];
}
/**
 * TStoreCategory describes the store category item. Each store item can be assigned to 1 or more categories
 */
export interface TStoreCategory {
	id: number;
	name: string;
	order: number;
}
/**
 * TStoreItem describes the information of the store item defined in the system
 */
export interface TStoreItem {
	/** ID of the store item  */
	id: number;
	/** Name of the store item, translated to the user language */
	name: string;
	/** Description of the store item, translated to the user language */
	description: string;
	/** URL of the image of the store item */
	image: string;
	/** Type of the store item. Can be 'bonus' or 'manual'. Manual, means it's tangible item, e.g. iPhone */
	type: 'bonus' | 'manual';
	/** The price of the store item in the gamification points */
	price: number;
	/** The ribbon of the store item. Can be 'sale', 'hot', 'new', 'vip' or URL to the image in case of custom ribbon */
	ribbon: TRibbon;
	/**
	 *  The message that should be shown to the user if he is not eligible to buy it. this message can be used to explain the reason why user cannot buy the item, e.g. 'You should be VIP to buy this item' and can be used in case can_buy property is false.
		The message is translated to the user language.
		**Note**: when user is trying to buy the item, the response from server can return custom error messages that can be shown to the user as well
	*/
	limit_message: string;
	/** The priority of the store item. Can be used to sort the items in the store */
	priority: number;
	/** The list of IDs of the related items. Can be used to show the related items in the store */
	related_item_ids: number[];
	/** The indicator if the user can buy the item
	 *  This indicator is taking into account the segment conditions for the store item, the price of item towards users balance,
	 */
	can_buy: boolean;
	/** The list of IDs of the categories where the store item is assigned, information about categories can be retrieved with getStoreCategories method */
	category_ids: number[];
	/** Number of items in the pool avaliable for the purchase.*/
	pool?: number;
	/** The T&C text for the store item */
	hint_text?: string;
	/** Purchase time to show in purchase history screen */
	purchase_ts?: number;
	/** The amount of points you can purchase an item */
	purchase_points_amount?: number;
}
/**
 * TAchCategory describes the badge category item. Each badge item can be assigned to 1 or more categories
 */
export interface TAchCategory {
	id: number;
	name: string;
	order: number;
}
/**
 * TMissionOrBadge describes the information of mission or badge defined in the system
 */
export interface TMissionOrBadge {
	/** ID of the mission or badge  */
	id: number;
	/** Type of entity. Can be 'mission' or 'badge' */
	type: 'mission' | 'badge';
	/** Name of the mission or badge, translated to the user language */
	name: string;
	/** Description of the mission or badge, translated to the user language */
	description: string;
	/** Description of the mission reward if defined */
	reward: string;
	/** URL of the image of the mission or badge */
	image: string;
	/** Indicator if the mission is completed or badge is granted */
	is_completed: boolean;
	/** Indicator if the mission is locked. Means that it's visible to the user, but he cannot progress in it until it's unlocked.
	 * Mission may optionally contain the explanation of what should be done to unlock it in the unlock_mission_description property
	 */
	is_locked: boolean;
	/** Optional explaination of what should be done to unlock the mission */
	unlock_mission_description: string;
	/** Indicator if the mission requires opt-in. Means that user should explicitly opt-in to the mission in order to start progressing in it */
	is_requires_optin: boolean;
	/** Indicator if the user opted-in to the mission */
	is_opted_in: boolean;
	/** The amount of time in milliseconds that user has to complete the mission */
	time_limit_ms: number;
	/** The date when the mission was started, relevant for the time limited missions */
	dt_start: number;
	/** The progress of the mission in percents calculated as the aggregated relative percentage of all tasks */
	progress: number;
	/**
	 * The action that should be performed when user clicks on the mission or badge
	 * Can be URL or deep link, e.g. 'dp:deposit'. The most safe to execute CTA is to pass it to _smartico.dp(cta_action);
	 * The 'dp' function will handle the CTA and will execute it in the most safe way
	 */
	cta_action: string;
	/** The text of the CTA button, e.g. 'Make a deposit' */
	cta_text: string;
	/**
	 * The ID of the custom section where the mission or badge is assigned
	 * The list of custom sections can be retrieved using _smartico.api.getCustomSections() method (TODO-API)
	 */
	custom_section_id: number;
	/** The indicator if the mission or badge is visible only in the custom section and should be hidden from the main overview of missions/badges */
	only_in_custom_section: boolean;
	/** The custom data of the mission or badge defined by operator. Can be a JSON object, string or number */
	custom_data: any;
	/** The list of tasks of the mission or badge */
	tasks: TMissionOrBadgeTask[];
	/** List of casino games (or other types of entities) related to the mission or badge */
	related_games?: AchRelatedGame$1[];
	/** The list of IDs of the categories where the badge item is assigned, information about categories can be retrieved with getAchCategories method */
	category_ids: number[];
	/** The T&C text for the missions */
	hint_text?: string;
	/** Priority (or position) of the mission in the UI. Low value indicates higher position in the UI */
	position?: number;
	/** The ribbon of the mission/badge item. Can be 'sale', 'hot', 'new', 'vip' or URL to the image in case of custom ribbon */
	ribbon?: TRibbon;
	/** ID of the completion fact from ach_completed or ach_completed_recurring tables */
	ach_completed_id?: number;
	/** Flag from achievement if the mission prize will be given only after user claims it */
	requires_prize_claim?: boolean;
	/** The date/timestamp indicating when the prize was claimed by the user */
	prize_claimed_date_ts?: number;
}

export enum BonusStatus {
    /** The bonus is newly created (shouldn't be shown to the client) */
    New = 1, 
    /** The bonus is issued and available for redemption but has not been redeemed yet */
    COUPON_ISSUED = 2,
    /** The bonus has been successfully redeemed */
    REDEEMED = 3,
    /** The bonus is still valid, but a previous redemption attempt failed */
    REDEEM_FAILED = 4, 
    /** Failed to issue the bonus (shouldn't be shown to the client) */
    COUPON_ISSUE_FAILED = 5, 
    /** The bonus was issued but has expired and can no longer be redeemed (shouldn't be shown to the client) */
    EXPIRED = 6, 
}

export interface BonusTemplateMetaMap {
	/** Description of the bonus template*/
	description: string;
	/** Acknowledge message setup in the bonus template*/
	acknowledge: string;
	/** Image URL of the bonus template*/
	image_url: string;
}

export interface BonusMetaMap {
	/** Label and description of the bonus sent to the player*/
	uiAmount?: string;
}

export interface TBonus {
	/** ID of the bonus */
	bonus_id: number;
	/** Can the bonus be redeemed (if bonus is redeemable the user needs to claim it) */
	is_redeemable?: boolean;
	/** Date of creation */
	create_date?: string;
	/** Date of last update */
	update_date?: string;
	/** Date of redemption */
	redeem_date?: string;
	/** Uniq identifier of the bonus sent to the player */
	engagement_uid?: string;
	/** ID of template used */
	label_bonus_template_id?: number;
	/** Reference ID of product */
	source_product_ref_id?: number;
	/** ID of product  */
	source_product_id?: number;
	/** ID of the user who created the bonus */
	user_id?: number;
	/** ID of the bonus status */
	bonus_status_id?: BonusStatus;
	/** Additional information about the bonus(edscription, image,name, acknowledge) */
	label_bonus_template_meta_map?: BonusTemplateMetaMap;
	/** Additional information presented to the player when the bonus is redeemed */
	bonus_meta_map?: BonusMetaMap;
}
interface AchRelatedGame$1 {
	/** The ID of the related game */
	ext_game_id: string;
	/** Game public meta information */
	game_public_meta: {
		/** The name of the game */
		name: string;
		/** The URL to the game */
		link: string;
		/** The URL to the image of the game */
		image: string;
		/** The indicator if the game is enabled */
		enabled: boolean;
		/** The list of categories of the game */
		game_categories: string[];
		/** The name of the game provider */
		game_provider: string;
	};
}
/**
 * TMissionOrBadgeTask describes the information of tasks that belings to mission or badge. See also TMissionOrBadge
 */
export interface TMissionOrBadgeTask {
	/** ID of the task */
	id: number;
	/** Name of the task, translated to the user language */
	name: string;
	/** Indicator if the task is completed */
	is_completed: boolean;
	/** The progress of the task in percents */
	progress: number;
	/** Reward for completing the task in points */
	points_reward: number;
}
/**
 * TMissionOptInResult describes the response of call to _smartico.api.requestMissionOptIn(mission_id) method
 */
export interface TMissionOptInResult {
	/** Error code that represents outcome of the opt-in request. Successful opt-in in case err_code is 0 */
	err_code: number;
	/** Optional error message */
	err_message: string;
}
/**
 * TMissionClaimRewardResult describes the response of call to _smartico.api.requestMissionClaimReward(mission_id, ach_completed_id) method
 */
export interface TMissionClaimRewardResult {
	/** Error code that represents outcome of the claim request. Successful claim reward in case err_code is 0 */
	err_code: number;
	/** Optional error message */
	err_message: string;
}
export interface TTournamentRegistrationResult {
	/** Error code that represents outcome of the tournament registration request. Successful registration in case err_code is 0 */
	err_code: TournamentRegistrationError;
	/** Optional error message */
	err_message: string;
}
export interface TBuyStoreItemResult {
	/** Error code representing the result of the purchase of the shop item. Successful purchase if err_code is 0 */
	err_code: BuyStoreItemErrorCode;
	/** Optional error message */
	err_message: string;
}
export interface TGetTranslations {
	translations: {
		[key: string]: string;
	};
}
export interface TInboxMessage {
	/** Uniq identifier of the message. It is needed to request the message body, mark the message as read/deleted/favorite. */
	message_guid: string;
	/** Date when the message was sent */
	sent_date: string;
	/** Indicator if a message is read */
	read: boolean;
	/** Indicator if a message is added to favorites */
	favorite: boolean;
}
export interface TInboxMessageBody {
	/** Message title */
	title: string;
	/** Short preview body of the message */
	preview_body: string;
	/** Message icon */
	icon: string;
	/** The action that should be performed when user clicks on the message.
	 * Can be URL or deep link, e.g. 'dp:deposit'. The most safe to execute CTA is to pass it to _smartico.dp(cta_action);
	 * The 'dp' function will handle the CTA and will execute it in the most safe way.
	 * If the message has a rich html body - the action will always be 'dp:inbox' which will open the inbox widget when triggered. */
	action: string;
	/** Rich HTML body of the message. */
	html_body?: string;
	/** Optional additional buttons to show in the message, available only if message has rich HTML body. Max count - 2. */
	buttons?: {
		/** The action that should be performed when user clicks on the button. The logic is the same as for message actions */
		action: string;
		/** Button text */
		text: string;
	}[];
}
export interface InboxMarkMessageAction {
	/** An error code representing the result of marking a message as deleted, favorite or read. Successful marking action if err_code is 0 */
	err_code: number;
	/** Optional error message */
	err_message: string;
}
export interface LeaderBoardDetailsT {
	/** ID of the leaderboard */
	board_id: number;
	/** Name of the leaderboard */
	name: string;
	/** Description of the leaderboard */
	description: string;
	/** Rules of the leaderboard */
	rules: string;
	/** Leaderboard period type ID */
	period_type_id: LeaderBoardPeriodType;
	/** Leaderboard points rewards */
	rewards: LeaderBoardsRewardsT[];
	/** Leaderboard users */
	users: LeaderBoardUserT[];
	/** Info about current user in leaderboard */
	me?: LeaderBoardUserT;
}
export interface LeaderBoardsRewardsT {
	place: number;
	points: number;
}
export interface LeaderBoardUserT {
	/** The username of the participant */
	public_username: string;
	/** The URL to the avatar of the participant */
	avatar_url: string;
	/** The position of the participant in the leaderboard */
	position: number;
	/** The points of the participant in the leaderboard */
	points: number;
	/** The indicator if the participant is current user */
	is_me: boolean;
}
export interface UserLevelExtraCountersT {
	/** The counter of 1st metric used to reach the level. */
	level_counter_1?: number;
	/** The counter of 2nd metric used to reach the level. */
	level_counter_2?: number;
}
export interface TSegmentCheckResult {
	segment_id: number;
	is_matching: boolean;
}
export interface SAWGetTemplatesResponse extends ProtocolResponse {
	templates: SAWTemplate[];
}
export interface GetLabelInfoResponse extends ProtocolResponse {
	settings: {
		[key: string]: string;
	};
	label_id: string;
}
declare enum TranslationArea {
	Casino = 1,
	Gamification = 2,
	Trading = 3,
	Archived = 4,
	Affiliation = 5,
	RetentionGames = 6,
	AffIliateAdminNew = 7,
}
export interface GetTranslationsResponse extends ProtocolResponse {
	hash_code: number;
	translations: {
		[key: string]: string;
	};
}
declare enum PublicLabelSettings$1 {
	PUBLIC_API_URL = 'PUBLIC_API_URL',
	RECORDING_ENABLED_FOR_ALL_USERS = 'RECORDING_ENABLED_FOR_ALL_USERS',
	JS_INJECTION = 'JS_INJECTION',
	GAMIFICATION_UI_MAIN = 'GAMIFICATION_UI_MAIN',
	GAMIFICATION_UI_WIDGET = 'GAMIFICATION_UI_WIDGET',
	GAMIFICATION_UI_MINI_GAME = 'GAMIFICATION_UI_MINI_GAME',
	GAMIFICATION_UI_SETTINGS = 'GAMIFICATION_UI_SETTINGS',
	GAMIFICATION_UI_MAIN_TEST = 'GAMIFICATION_UI_MAIN_TEST',
	GAMIFICATION_UI_WIDGET_TEST = 'GAMIFICATION_UI_WIDGET_TEST',
	GAMIFICATION_UI_SETTINGS_TEST = 'GAMIFICATION_UI_SETTINGS_TEST',
	FRONT_END_ALLOWED_LANGUAGES = 'FRONT_END_ALLOWED_LANGUAGES',
	FRONT_END_ALLOW_DOMAINS = 'FRONT_END_ALLOW_DOMAINS',
	DELAY_ENGAGEMENT_EXECUTION_ON_LOGIN_MS = 'DELAY_ENGAGEMENT_EXECUTION_ON_LOGIN_MS',
	SHADOW_LABEL_PUBLIC_KEY = 'SHADOW_LABEL_PUBLIC_KEY',
	DYNAMIC_IMAGE_DOMAIN = 'DYNAMIC_IMAGE_DOMAIN',
	GAMIFICATION_UI_LEVEL_ENABLED = 'GAMIFICATION_UI_LEVEL_ENABLED',
	GAMIFICATION_UI_LEVEL_IMAGE_MOB = 'GAMIFICATION_UI_LEVEL_IMAGE_MOB',
	GAMIFICATION_UI_LEVEL_IMAGE_DESK = 'GAMIFICATION_UI_LEVEL_IMAGE_DESK',
	GAMIFICATION_LEVELS_LOGIC2 = 'GAMIFICATION_LEVELS_LOGIC2',
	GAMIFICATION_LEVELS_LOGIC3 = 'GAMIFICATION_LEVELS_LOGIC2',
	AVATAR_CUSTOM_IMAGE_MAX_ID = 'AVATAR_CUSTOM_IMAGE_MAX_ID',
	AVATAR_CUSTOM_IMAGE_FOLDER = 'AVATAR_CUSTOM_IMAGE_FOLDER',
	GAMIFICATION_SHOW_POWERED_BY = 'GAMIFICATION_SHOW_POWERED_BY',
	_system_leader_board_mask_username = '_system_leader_board_mask_username',
	INBOX_PUBLIC_CDN = 'INBOX_PUBLIC_CDN',
}
interface PublicProperties$1 {
	core_user_language?: string;
	ach_points_balance?: number;
	ach_points_ever?: number;
	ach_level_current_id?: number;
	ach_level_current?: string;
	core_is_test_account?: boolean;
	ach_gamification_in_control_group?: boolean;
}
export interface ResponseIdentify extends ProtocolResponse {
	user_id: number;
	ext_user_id: string;
	public_username: string;
	avatar_id: string;
	job: boolean;
	props?: PublicProperties$1;
	pubic_username_set: boolean;
}
declare enum InboxMessageType {
	Custom = 0,
	MissionCompleted = 1,
	MissionUnlocked = 2,
	LeaderboardWon = 3,
	LevelChanged = 4,
	BonusGiven = 5,
	PointsAdded = 6,
	PointsUsed = 7,
	PersonalMessage = 8,
}
export interface InboxMessageBody {
	action: string;
	body: string;
	type: InboxMessageType;
	image: string;
	title: string;
	html_body: string;
	additional_buttons?: {
		inbox_cta_text: string;
		action: string;
	}[];
}
export interface InboxMessage {
	createDate: string;
	body: InboxMessageBody;
	engagement_uid: string;
	is_read: boolean;
	is_starred: boolean;
	is_deleted?: boolean;
}
export interface GetInboxMessagesResponse extends ProtocolResponse {
	log: InboxMessage[];
}
export interface MarkInboxMessageReadResponse extends ProtocolMessage {
	errCode: number;
	errMsg?: string;
}
export interface MarkInboxMessageStarredResponse extends ProtocolMessage {
	errCode: number;
	errMsg?: string;
}
export interface MarkInboxMessageDeletedResponse extends ProtocolMessage {
	errCode: number;
	errMsg?: string;
}
export interface AchievementOptinResponse extends ProtocolResponse {}
export interface AchievementPublicMeta {
	description?: string;
	unlock_mission_description?: string;
	custom_data?: string;
	cta_text?: string;
	cta_action?: string;
	label_tag?: string;
	custom_label_tag?: string;
	reward?: string;
	image_url?: string;
	name?: string;
	position?: number;
	hide_tasks?: boolean;
	hide_locked_mission?: boolean;
	custom_section_id?: number;
	only_in_custom_section?: boolean;
	hint_text?: string;
	hide_badge_from_ui?: boolean;
	show_badge_first_task_completed?: boolean;
}
declare enum AchievementStatus {
	Draft = 1,
	AvailableUnlocked = 2,
	AvailableLocked = 3,
	Archived = 4,
	FeaturedManually = 5,
	FeaturedAI = 6,
}
export interface AchievementTaskPublicMeta {
	name?: string;
}
declare enum AchievementTaskType {
	CompleteAchievement = 1,
	UnlockAchievement = 2,
}
declare enum AchievementType {
	Mission = 1,
	Badge = 2,
}
declare enum ScheduledMissionType {
	Future = 1,
	Past = 2,
	Present = 3,
}
export interface UserAchievementTask {
	task_id?: number;
	task_public_meta?: AchievementTaskPublicMeta;
	points_reward?: number;
	task_type_id: AchievementTaskType;
	isCompleted?: boolean;
	userExecutedCount?: number;
	userProgress?: number;
	lastExecutionDate: string;
	unlocked_by_mission_id?: number;
	unlocked_by_level_id?: number;
}
export interface UserAchievement {
	ach_id?: number;
	ach_type_id?: AchievementType;
	ach_public_meta?: AchievementPublicMeta;
	isCompleted?: boolean;
	isLocked?: boolean;
	requiresOptin?: boolean;
	isOptedIn?: boolean;
	start_date?: string; // time when mission unlocked or opted-in. Needed to calculated "remaining time" in case time_limit_ms is set
	start_date_ts?: number;
	time_limit_ms?: number;
	progress?: number;
	complete_date?: string;
	complete_date_ts?: number;
	unlock_date?: string;
	milliseconds_till_available?: number;
	completed_tasks?: number;
	achievementTasks?: UserAchievementTask[];
	next_recurrence_date_ts?: number;
	ach_status_id?: AchievementStatus;
	scheduledMissionType?: ScheduledMissionType;
	related_games?: AchRelatedGame[];
	active_from_ts?: number; // indicates when 'scheduled' mission is active from,
	active_till_ts?: number; // indicates when 'scheduled' mission is active till,
	ach_categories?: number[];
	recurring_quantity?: number; // max completion count for Recurring upon completion
	completed_count?: number; // completion count for Recurring upon completion

	ach_completed_id?: number; // ID of the completion fact from ach_completed or ach_completed_recurring tables
	requires_prize_claim?: boolean; // flag from achievement if the mission prize will be given only after user claims it
	prize_claimed_date_ts?: number; // the date/timestamp indicating when the prize was claimed by the user

	completed_today?: boolean;
	completed_this_week?: boolean;
	completed_this_month?: boolean;
	custom_section_type_id?: number;
}
export interface GetAchievementMapResponse extends ProtocolResponse {
	achievements?: UserAchievement[];
}
export interface AchCategoryPublicMeta {
	name?: string;
	order?: number;
}
export interface AchCategory {
	id?: number;
	publicMeta?: AchCategoryPublicMeta;
}
export interface GetAchCategoriesResponse extends ProtocolResponse {
	categories: AchCategory[];
}
export interface AchClaimPrizeResponse extends ProtocolResponse {}
export interface LevelPublicMeta {
	/** Description of level, HTML capabable */
	description?: string;
	/** URL to the image of level */
	image_url?: string;
	/** Name of level */
	name?: string;
	/** Number of points that user should have collected in order to see this level */
	visibility_points?: number;
	/** X & Y coordinates of level on the visual mission map, for desktop and mobile */
	position?: {
		mx: number;
		my: number;
		dx: number;
		dy: number;
	};
	/**custom data as string or JSON string that can be used in UIWidget */
	custom_data: string;
}
export interface Level {
	level_id: number;
	level_public_meta: LevelPublicMeta;
	required_points: number;
	is_first_level: boolean;
	/** Internal status of level. Not in use right now on the front-end */
	level_status_id: number;
	required_level_counter_1: number;
	required_level_counter_2: number;
	general_level_progress: number;
}
export interface GetLevelMapResponse extends ProtocolResponse {
	levels: Level[];
}
declare class WSAPI {
	private api;
	private onUpdateCallback;
	/** @private */
	constructor(api: SmarticoAPI);
	/** Returns information about current user
	 * Example usage:
	 * ```
	 * _smartico.api.getUserProfile().then((result) => {
	 *  console.log(result);
	 * });
	 * ```
	 * */
	getUserProfile(): TUserProfile;
	/** Check if user belongs to specific segments
	 * Example usage:
	 * ```
	 * _smartico.api.checkSegmentMatch(1).then((result) => {
	 *   console.log(result);
	 * });
	 * ```
	 */
	checkSegmentMatch(segment_id: number): Promise<boolean>;
	/** Check if user belongs to specific list of segments
	 * Example usage:
	 * ```
	 * _smartico.api.checkSegmentListMatch([1, 2, 3]).then((result) => {
	 *    console.log(result);
	 * });
	 * ```
	 */
	checkSegmentListMatch(segment_ids: number[]): Promise<TSegmentCheckResult[]>;
	/** Returns all the levels available the current user
	 * Example usage:
	 * ```
	 * _smartico.api.getLevels().then((result) => {
	 *   console.log(result);
	 * });
	 * ```
	 */
	getLevels(): Promise<TLevel[]>;
	/** Returns all the missions available the current user.
	 * The returned missions are cached for 30 seconds. But you can pass the onUpdate callback as a parameter.
	 * Note that each time you call getMissions with a new onUpdate callback, the old one will be overwritten by the new one.
	 * The onUpdate callback will be called on mission OptIn and the updated missions will be passed to it.
	 * Example usage:
	 * ```
	 * _smartico.api.getMissions().then((result) => {
	 *  console.log(result);
	 * });
	 * ```
	 /**
	 * @param params
	 */
	getMissions({ onUpdate }?: { onUpdate?: (data: TMissionOrBadge[]) => void }): Promise<TMissionOrBadge[]>;
	/** Returns all the badges available the current user */
	getBadges(): Promise<TMissionOrBadge[]>;
	/** Returns all the badges available the current user */
	getBonuses(): Promise<TBonus[]>;
	/**
	 * Returns the extra counters for the current user level.
	 * These are counters that are configured for each Smartico client separatly by request.
	 * For example 1st counter could be total wagering amount, 2nd counter could be total deposit amount, etc.
	 * Example usage:
	 * ```
	 * _smartico.api.getUserLevelExtraCounters().then((result) => {
	 *      console.log(result);
	 * });
	 * ```
	 */
	getUserLevelExtraCounters(): Promise<UserLevelExtraCountersT>;
	/** Returns all the store items available the current user
	 * Example usage:
	 * ```
	 * _smartico.api.getStoreItems().then((result) => {
	 *      console.log(result);
	 * });
	 */
	getStoreItems(): Promise<TStoreItem[]>;
	/** Buy the specific shop item by item_id. Returns the err_code in case of success or error.
	 * Example usage:
	 * ```
	 * _smartico.api.buyStoreItem(1).then((result) => {
	 *     console.log(result);
	 * });
	 */
	buyStoreItem(item_id: number): Promise<TBuyStoreItemResult>;
	/** Returns store categories */
	getStoreCategories(): Promise<TStoreCategory[]>;
	/** Returns store purchased items based on the provided parameters. "From" and "to" indicate the range of items to be fetched.
	 * The maximum number of messages per request is limited to 20.
	 * You can leave this params empty and by default it will return list of purchased items ranging from 0 to 20.
	 * This functions return list of purchased items.
	 * The "onUpdate" callback will be triggered when the user receives a new purchased item. It will provide an updated list of items, ranging from 0 to 20, to the onUpdate callback function. */
	/**
	 * @param params
	 */
	storeGetPurchasedItems({
		from,
		to,
		onUpdate,
	}?: {
		from?: number;
		to?: number;
		onUpdate?: (data: TStoreItem[]) => void;
	}): Promise<TStoreItem[]>;
	/** Returns missions & badges categories */
	getAchCategories(): Promise<TAchCategory[]>;
	/** Returns the list of mini-games available for user
	 * The returned list of mini-games is cached for 30 seconds. But you can pass the onUpdate callback as a parameter. Note that each time you call getMiniGames with a new onUpdate callback, the old one will be overwritten by the new one.
	 * The onUpdate callback will be called on available spin count change, if mini-game has increasing jackpot per spin or wined prize is spin/jackpot and if max count of the available user spin equal one, also if the spins were issued to the user manually in the BO. Updated templates will be passed to onUpdate callback. */
	/**
	/**
	 * @param params
	 */
	getMiniGames({ onUpdate }?: { onUpdate?: (data: TMiniGameTemplate[]) => void }): Promise<TMiniGameTemplate[]>;
	/** Plays the specified by template_id mini-game on behalf of user and returns prize_id or err_code  */
	playMiniGame(template_id: number): Promise<TMiniGamePlayResult>;
	/** Requests an opt-in for the specified mission_id. Returns the err_code. */
	requestMissionOptIn(mission_id: number): Promise<TMissionOptInResult>;
	/** Request for claim reward for the specified mission id. Returns the err_code. */
	requestMissionClaimReward(mission_id: number, ach_completed_id: number): Promise<TMissionClaimRewardResult>;
	/** Returns all the active instances of tournaments
	 * The returned list is cached for 30 seconds. But you can pass the onUpdate callback as a parameter. Note that each time you call getTournamentsList with a new onUpdate callback, the old one will be overwritten by the new one.
	 * The onUpdate callback will be called when the user has registered in a tournament. Updated list will be passed to onUpdate callback.*/
	/**
	 * @param params
	 */
	getTournamentsList({ onUpdate }?: { onUpdate?: (data: TTournament[]) => void }): Promise<TTournament[]>;
	/** Returns details information of specific tournament instance, the response will include tournament info and the leaderboard of players */
	getTournamentInstanceInfo(tournamentInstanceId: number): Promise<TTournamentDetailed>;
	/** Requests registration for the specified tournament instance. Returns the err_code. */
	registerInTournament(tournamentInstanceId: number): Promise<TTournamentRegistrationResult>;
	/** Returns the leaderboard for the current type (default is Daily). If getPreviousPeriod is passed as true, a leaderboard for the previous period for the current type will be returned.
		For example, if the type is Weekly and getPreviousPeriod is true, a leaderboard for the previous week will be returned.
	 */
	getLeaderBoard(periodType: LeaderBoardPeriodType, getPreviousPeriod?: boolean): Promise<LeaderBoardDetailsT>;
	/** Returns inbox messages based on the provided parameters. "From" and "to" indicate the range of messages to be fetched.
	 * The maximum number of messages per request is limited to 20. An indicator "onlyFavorite" can be passed to get only messages marked as favorites.
	 * You can leave this params empty and by default it will return list of messages ranging from 0 to 20.
	 * This functions return list of messages without the body of the message.
	 * To get the body of the message you need to call getInboxMessageBody function and pass the message guid contained in each message of this request.
	 * All other action like mark as read, favorite, delete, etc. can be done using this message GUID.
	 * The "onUpdate" callback will be triggered when the user receives a new message. It will provide an updated list of messages, ranging from 0 to 20, to the onUpdate callback function. */
	/**
	 * @param params
	 */
	getInboxMessages({
		from,
		to,
		onlyFavorite,
		onUpdate,
	}?: {
		from?: number;
		to?: number;
		onlyFavorite?: boolean;
		onUpdate?: (data: TInboxMessage[]) => void;
	}): Promise<TInboxMessage[]>;
	/** Returns the message body of the specified message guid. */
	getInboxMessageBody(messageGuid: string): Promise<TInboxMessageBody>;
	/** Requests to mark inbox message with specified guid as read */
	markInboxMessageAsRead(messageGuid: string): Promise<InboxMarkMessageAction>;
	/** Requests to mark all inbox messages as read */
	markAllInboxMessagesAsRead(): Promise<InboxMarkMessageAction>;
	/** Requests to mark inbox message with specified guid as favorite. Pass mark true to add message to favorite and false to remove. */
	markUnmarkInboxMessageAsFavorite(messageGuid: string, mark: boolean): Promise<InboxMarkMessageAction>;
	/** Requests to delete inbox message */
	deleteInboxMessage(messageGuid: string): Promise<InboxMarkMessageAction>;
	/** Requests to delete all inbox messages */
	deleteAllInboxMessages(): Promise<InboxMarkMessageAction>;
	/** Requests translations for the given language. Returns the object including translation key/translation value pairs. All possible translation keys defined in the back office. */
	getTranslations(lang_code: string): Promise<TGetTranslations>;
	private updateOnSpin;
	private updateOnAddSpin;
	private updateOnPrizeWin;
	private updateMissionsOnOptIn;
	private updateTournamentsOnRegistration;
	private updateInboxMessages;
	private updateEntity;
}
export interface GetAchievementsUserInfoResponse extends ProtocolResponse {
	level_counter_1?: number;
	level_counter_2?: number;
}
export interface Tracker {
	label_api_key: string;
	userPublicProps: any;
	on: (callBackKey: ClassId, func: (data: any) => void) => void;
	getLabelSetting: (key: PublicLabelSettings$1) => any;
}
export interface IOptions {
	logger?: ILogger;
	logCIDs?: ClassId[];
	logHTTPTiming?: boolean;
	tracker?: Tracker;
}
export type MessageSender = (message: any, publicApuUrl?: string, expectCID?: ClassId) => Promise<any>;
declare class SmarticoAPI {
	private label_api_key;
	private brand_api_key;
	private messageSender;
	private publicUrl;
	private wsUrl;
	private inboxCdnUrl;
	private partnerUrl;
	avatarDomain: string;
	private logger;
	private logCIDs;
	private logHTTPTiming;
	tracker?: Tracker;
	constructor(label_api_key: string, brand_api_key: string, messageSender: MessageSender, options?: IOptions);
	static getEnvDnsSuffix(label_api_key: string): string;
	static getEnvId(label_api_key: string): number;
	static getCleanLabelApiKey(label_api_key: string): string;
	static getPublicUrl(label_api_key: string): string;
	static getPublicWsUrl(label_api_key: string): string;
	static getAvatarUrl(label_api_key: string): string;
	private send;
	private buildMessage;
	coreReportCustomEvent(user_ext_id: string, eventType: string, payload?: any): Promise<any>;
	coreGetTranslations(
		user_ext_id: string,
		lang_code: string,
		areas: TranslationArea[],
		cacheSec?: number,
	): Promise<GetTranslationsResponse>;
	coreIdentifyLabel(user_ext_id: string, cacheSec?: number): Promise<GetLabelInfoResponse>;
	coreIdentifyUser(user_ext_id: string): Promise<ResponseIdentify>;
	coreChangeUsername(
		user_ext_id: string,
		public_username_custom: string,
	): Promise<{
		public_username_custom: string;
	}>;
	coreCheckSegments(user_ext_id: string, segment_id: number[]): Promise<TSegmentCheckResult[]>;
	sawGetTemplates(user_ext_id: string, lang?: string, is_visitor_mode?: boolean): Promise<SAWGetTemplatesResponse>;
	sawGetTemplatesT(user_ext_id: string): Promise<TMiniGameTemplate[]>;
	doAcknowledgeRequest(user_ext_id: string, request_id: string): Promise<SAWDoAknowledgeResponse>;
	sawSpinRequest(user_ext_id: string, saw_template_id: number, round_id?: number): Promise<SAWDoSpinResponse>;
	missionOptIn(user_ext_id: string, mission_id: number): Promise<AchievementOptinResponse>;
	missionClaimPrize(user_ext_id: string, mission_id: number, ach_completed_id: number): Promise<AchClaimPrizeResponse>;
	registerInTournament(user_ext_id: string, tournamentInstanceId: number): Promise<TournamentRegisterResponse>;
	buyStoreItem(user_ext_id: string, itemId: number): Promise<BuyStoreItemResponse>;
	inboxGetMessages(user_ext_id: string, limit?: number, offset?: number): Promise<GetInboxMessagesResponse>;
	storeGetItems(user_ext_id: string): Promise<GetStoreItemsResponse>;
	storeGetItemsT(user_ext_id: string): Promise<TStoreItem[]>;
	storeGetCategories(user_ext_id: string): Promise<GetCategoriesStoreResponse>;
	storeGetCategoriesT(user_ext_id: string): Promise<TStoreCategory[]>;
	storeGetPurchasedItems(user_ext_id: string, limit?: number, offset?: number): Promise<GetStoreHistoryResponse>;
	storeGetPurchasedItemsT(user_ext_id: string, from?: number, to?: number): Promise<TStoreItem[]>;
	missionsGetItems(user_ext_id: string): Promise<GetAchievementMapResponse>;
	missionsGetItemsT(user_ext_id: string): Promise<TMissionOrBadge[]>;
	getUserGamificationInfo(user_ext_id: string): Promise<GetAchievementsUserInfoResponse>;
	getUserGamificationInfoT(user_ext_id: string): Promise<UserLevelExtraCountersT>;
	achGetCategories(user_ext_id: string): Promise<GetAchCategoriesResponse>;
	achGetCategoriesT(user_ext_id: string): Promise<TAchCategory[]>;
	badgetsGetItems(user_ext_id: string): Promise<GetAchievementMapResponse>;
	badgetsGetItemsT(user_ext_id: string): Promise<TMissionOrBadge[]>;
	tournamentsGetLobby(user_ext_id: string): Promise<GetTournamentsResponse>;
	tournamentsGetLobbyT(user_ext_id: string): Promise<TTournament[]>;
	tournamentsGetInfo(user_ext_id: string, tournamentInstanceId: number): Promise<GetTournamentInfoResponse>;
	tournamentsGetInfoT(user_ext_id: string, tournamentInstanceId: number): Promise<TTournamentDetailed>;
	leaderboardGet(
		user_ext_id: string,
		period_type_id?: LeaderBoardPeriodType,
		prevPeriod?: boolean,
	): Promise<LeaderBoardDetails>;
	leaderboardsGetT(
		user_ext_id: string,
		period_type_id?: LeaderBoardPeriodType,
		prevPeriod?: boolean,
	): Promise<LeaderBoardDetailsT>;
	levelsGet(user_ext_id: string): Promise<GetLevelMapResponse>;
	levelsGetT(user_ext_id: string): Promise<TLevel[]>;
	getTranslationsT(
		user_ext_id: string,
		lang_code: string,
		areas: TranslationArea[],
		cacheSec?: number,
	): Promise<GetTranslationsResponse>;
	getInboxMessages(
		user_ext_id: string,
		limit: number,
		offset: number,
		starred_only: boolean,
	): Promise<GetInboxMessagesResponse>;
	getInboxMessagesT(user_ext_id: string, from?: number, to?: number, favoriteOnly?: boolean): Promise<TInboxMessage[]>;
	getInboxMessageBody(messageGuid: string): Promise<InboxMessageBody>;
	getInboxMessageBodyT(messageGuid: string): Promise<TInboxMessageBody>;
	markInboxMessageRead(user_ext_id: string, messageGuid: string): Promise<MarkInboxMessageReadResponse>;
	markAllInboxMessageRead(user_ext_id: string): Promise<MarkInboxMessageReadResponse>;
	markUnmarkInboxMessageAsFavorite(
		user_ext_id: string,
		messageGuid: string,
		mark: boolean,
	): Promise<MarkInboxMessageStarredResponse>;
	deleteInboxMessage(user_ext_id: string, messageGuid: string): Promise<MarkInboxMessageDeletedResponse>;
	deleteAllInboxMessages(user_ext_id: string): Promise<MarkInboxMessageDeletedResponse>;
	getWSCalls(): WSAPI;
}
export interface SmarticoClearParams {
	keepCallBacks: boolean;
}
export interface RequestBase {
	cid?: number;
	ts?: number;
	uuid?: string;
}
export interface RequestClientEngagmentBase extends RequestBase {
	engagement_uid: string;
	activityType: CJMActivityType;
}
export interface RequestClientEngagementAction extends RequestClientEngagmentBase {
	action?: string;
}
export interface RequestClientEngagementFailed extends RequestClientEngagmentBase {
	action?: string;
	reason?: string;
}
declare enum EWidgetType {
	Achievements2 = 'achievements2',
	Achievements = 'achievements',
	ShortInfo1 = 'short_info1',
	ShortInfo = 'short_info',
	Tournaments = 'tournaments',
	Store = 'store',
	Inbox = 'inbox',
	Missions = 'missions',
	MiniGame = 'mini-game',
	MatchX = 'match-x',
	MatchXNew = 'match-x-2',
	CustomSection = 'custom-section',
	InboxWidget = 'inbox-widget',
	UIWidget = 'ui-widget',
}
declare enum EXTERNAL_CALLBACK_KEY {
	INIT = 'init',
	IDENTIFY = 'identify',
	LOGIN = 'login',
	LOGOUT = 'logout',
	USER_PROPS_CHANGE = 'props_change',
	SESSION_BASED_DP_DETECTED = 'session_based_dp_detected',
	GF_CLOSING = 'gf_closing',
	GF_STARTING = 'gf_starting',
	GF_STARTED = 'gf_started',
	SAW_STARTING = 'saw_starting',
	INBOX_STARTING = 'inbox_starting',
	PROTOCOL_ERROR = 'protocol_error',
	MNIGAME_WIN = 'mini_game_win',
	ACH_GAME_OPENING = 'ach_game_opening',
}
declare enum DpType {
	AskPushPermissions = 'ask_push_permissions',
	Ok = 'ok',
	Cancel = 'cancel',
	Close = 'close',
	Go = 'go',
	Inbox = 'inbox',
	GfMain = 'gf',
	Activity = 'gf_activity',
	Missions = 'gf_missions',
	Badges = 'gf_badges',
	LeaderBoard = 'gf_board',
	Tournaments = 'gf_tournaments',
	LeaderBoardPrev = 'gf_board_previous',
	LeaderBoardRules = 'gf_board_rules',
	Bonuses = 'gf_bonuses',
	Levels = 'gf_levels',
	Saw = 'gf_saw',
	MatchX = 'gf_matchx',
	Store = 'gf_store',
	Settings = 'gf_settings',
	Section = 'gf_section',
	GfClose = 'gf_close',
	ChangeNickname = 'gf_change_nickname',
	ChangeAvatar = 'gf_change_avatar',
	Submit = 'submit',
	Action = 'action',
}
export interface DeepLinkParams {
	[key: string]: string;
}
export interface DeepLink {
	action: DpType;
	params?: DeepLinkParams;
	actionToReport?: string;
}
export interface IVisitorGameParams {
	template_id: number;
	onBeforePlay: () => boolean;
	onWin: (prize: SAWPrize) => void;
	frame_id: string;
}
export interface IWidgetParams {
	iframe: string;
	zoom: number;
	height: 'auto' | string;
	theme: string;
	wuuid: string;
	withBridge?: any;
	noQuestionMark?: any;
	inline?: boolean;
	force_mobile?: boolean;
}
declare enum ConnectionStatus {
	OPEN = 0,
	CLOSED = 1,
}
export interface TrackerInterface {
	log?: (message: string) => void;
	clear?: (params: SmarticoClearParams) => void;
	logout?: (payload: any) => void;
	reportEngagmentAction: (message: RequestClientEngagementAction) => void;
	reportEngagmentFail: (message: RequestClientEngagementFailed) => void;
	reportEngagmentImpression: (message: RequestClientEngagementFailed) => void;
	requestPushPermissions: () => void;
	executeNativeDp: (dp: string) => void;
	executeGfDp: (dp: DeepLink) => void;
	executeManualDP?: (deepLink: string, engagement_uid?: string, activityType?: CJMActivityType) => void;
	promoMessageClosed: () => void;
	connectionStatus?: ConnectionStatus;
	suspendPopups?: (flag: boolean) => void;
	suspendInbox?: (flag: boolean) => void;
	registerNativePushToken?: (token: string, platform: PushClientPlatform, app_package_id: any) => void;
	registerHandler?: (cid: ClassId, handler: (o: any) => void) => void;
	triggerExternalCallBack?: (callBackKey: EXTERNAL_CALLBACK_KEY | number, ...args: any[]) => void;
	getExtUserId?: () => string;
	bSuspendPopups?: boolean;
	identify?: (ext_user_id: string, hash: string, payload: any, visitor_id: string) => void;
	changeLanguage?: (lang: string) => void;
	getPublicProps?: () => PublicProperties;
	getLabelSetting?: (key: PublicLabelSettings) => any;
	getParams?: () => typeof TrackerParams;
	setNickname?: (nickname: string) => void;
	setAvatar?: (avatar_id: string) => void;
	setLoginPayload?: (payload: any) => void;
	sendServerError?: (message: string) => void;
	sendServerDebug?: (message: string) => void;
	sendAnalytics?: (
		activity_id: ClientActivityRequestId,
		type: 'view' | 'click' | 'other',
		view_time_sec?: number,
		more?: any,
	) => void;
	sendRow: (cid: ClassId, toIdentified: boolean, data?: any) => string;
	miniGame?: (saw_template_id: string, params: IWidgetParams) => void;
	showWidget?: (widgetType: EWidgetType, params: IWidgetParams) => void;
	showVisitorGame?: (params: IVisitorGameParams) => void;
	convertVisitorGame?: (visitor_win_uuid: string) => void;
	isIdenfitied?: () => boolean;
}
declare const TrackerParams: {
	brand_key: any;
	debug: boolean;
	server: any;
	simulation_mode: boolean;
	gamification_wrapper_mode: boolean;
	generate_visit: boolean;
	lang: string;
};
declare const CallBackDefaultParams: {};
declare class GamificationEngine {
	private static _instance;
	private readonly _tracker;
	private readonly _socketPromises;
	private readonly _socketListeners;
	static instance(tracker: TrackerInterface): GamificationEngine;
	private constructor();
	doGetLevels: () => Promise<any>;
	doGetMissions: () => Promise<any>;
	doOptinMission: (achievementId: number) => Promise<any>;
	doClaimRewardMission: (achievementId: number) => Promise<any>;
	doGetTournaments: () => Promise<any>;
	doGetTournamentLobby: (tournamentInstanceId: number) => Promise<any>;
	doTournamentRegister: (tournamentInstanceId: number) => Promise<any>;
	private socketRequest;
	private socketResponse;
	private listen;
	private notify;
}
declare enum ClientEventTypes {
	client_action = 'client_action',
	update_sensitive_properties = 'update_sensitive_properties',
	core_language_changed = 'core_language_changed',
	core_cannot_open_gamification = 'core_cannot_open_gamification',
	core_set_last_login_entry = 'core_set_last_login_entry',
	gf_nickname_changed = 'gf_nickname_changed',
	gf_avatar_changed = 'gf_avatar_changed',
}
declare class Smartico {
	private static tracker;
	private static trackerShadow;
	private static initParams;
	private static initLabelApiKey;
	private static shadowQueue;
	private static shadowInterval;
	static gf: GamificationEngine;
	static api: WSAPI;
	private static readonly gf_api_promises;
	private static readonly gf_api_handlers;
	constructor();
	static startIntegrationWithIframe(): void;
	private static checkInit;
	private static checkSuccessfullyIdentify;
	private static initShadowLabel;
	private static onlineTrackerInterval;
	private static onlineTrackerLastUserId;
	private static onlineTrackerLastLanguage;
	private static getUserID;
	private static getUserHash;
	private static getLanguage;
	private static getVisitorGameWinUUID;
	private static getVisitorID;
	private static onlinetrackerByInterval;
	static init(label_api_key: string, params: typeof TrackerParams): void;
	static initVisitorMode(label_api_key: string, params: typeof TrackerParams): void;
	static clear(params?: SmarticoClearParams): void;
	static getPublicProps(): PublicProperties;
	static sendServerError(message: string): void;
	static sendServerDebug(message: string): void;
	static requestPushPermissions(): void;
	static registerNativePushToken(token: string, platform?: PushClientPlatform, app_package_id?: string): void;
	static identify(ext_user_id: string, hash: string, payload: any): Promise<void>;
	static online(ext_user_id: string, language: string, user_hash: string): Promise<void>;
	static login(language?: string, payload?: any): void;
	static logout(payload?: any): void;
	static changeLanguage(language: string): void;
	static event(eventType: ClientEventTypes, payload?: any): void;
	static sendRow(cid: ClassId, payload?: any): void;
	static action(actionValue: any): void;
	static setLoginEntry(core_last_login_entry: string): void;
	static setAvatar(avatar_id: string): void;
	static setNickname(nickname: string): void;
	static dp(deepLink: string): void;
	static miniGame(saw_template_id: string, params: IWidgetParams): void;
	static showWidget(widgetType: EWidgetType, params: IWidgetParams): void;
	static sendAnalytics(activity_id: ClientActivityRequestId, view_time_sec?: number): void;
	static on(callBackKey: EXTERNAL_CALLBACK_KEY, f: null | (() => void), params?: typeof CallBackDefaultParams): void;
	static suspendPopups(flag: boolean): void;
	static suspendInbox(flag: boolean): void;
	static parseUrl(): any;
	static parseUrlHash(): any;
	static isMobile(): boolean;
	static showVisitorGame(params: IVisitorGameParams): void;
	static convertVisitorGame(visitor_win_uuid: string): void;
	private static customScripts;
}

export { Smartico as default };

export {};
